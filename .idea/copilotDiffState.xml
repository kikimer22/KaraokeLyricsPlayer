<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/lib/utils_clean.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lib/utils_clean.ts" />
              <option name="updatedContent" value="import type { LrcLine, SongData, WordEntry } from '@/lib/types';&#10;&#10;export const getOpacity = (distance: number) =&gt; {&#10;  if (distance === 0) return 1;&#10;  if (distance === 1 || distance === -1) return 0.7;&#10;  if (distance === 2 || distance === -2) return 0.5;&#10;  if (distance === 3 || distance === -3) return 0.3;&#10;  if (distance &gt;= 4 || distance &lt;= -4) return 0.1;&#10;};&#10;&#10;export const formatTime = (ms: number) =&gt; {&#10;  const totalSeconds = Math.floor(ms / 1000);&#10;  const minutes = Math.floor(totalSeconds / 60);&#10;  const seconds = totalSeconds % 60;&#10;  return `${minutes}:${seconds &lt; 10 ? '0' : ''}${seconds}`;&#10;};&#10;&#10;export const findCurrentIndex = (&#10;  lrc: readonly { milliseconds: number }[],&#10;  currentTimeMs: number&#10;): number =&gt; {&#10;  let low = 0;&#10;  let high = lrc.length - 1;&#10;  let result = -1;&#10;&#10;  while (low &lt;= high) {&#10;    const mid = Math.floor((low + high) / 2);&#10;    const line = lrc[mid];&#10;    const nextLine = lrc[mid + 1];&#10;&#10;    if (currentTimeMs &gt;= line.milliseconds &amp;&amp; (!nextLine || currentTimeMs &lt; nextLine.milliseconds)) {&#10;      result = mid;&#10;      break;&#10;    }&#10;&#10;    if (currentTimeMs &lt; line.milliseconds) {&#10;      high = mid - 1;&#10;    } else {&#10;      low = mid + 1;&#10;    }&#10;  }&#10;&#10;  return result;&#10;};&#10;&#10;export const mapWordsToLines = (&#10;  lrcLines: readonly LrcLine[],&#10;  richSyncWords: readonly WordEntry[]&#10;): Map&lt;string, WordEntry[]&gt; =&gt; {&#10;  const lineWordsMap = new Map&lt;string, WordEntry[]&gt;();&#10;&#10;  if (!richSyncWords || richSyncWords.length === 0 || lrcLines.length === 0) {&#10;    return lineWordsMap;&#10;  }&#10;&#10;  let currentLineWords: WordEntry[] = [];&#10;  let lrcIndex = 0;&#10;&#10;  for (const word of richSyncWords) {&#10;    currentLineWords.push(word);&#10;&#10;    if (word.isEndOfLine) {&#10;      if (lrcIndex &lt; lrcLines.length) {&#10;        const lineId = lrcLines[lrcIndex]._id.$oid;&#10;        lineWordsMap.set(lineId, [...currentLineWords]);&#10;        lrcIndex++;&#10;        currentLineWords = [];&#10;      }&#10;    }&#10;  }&#10;&#10;  if (currentLineWords.length &gt; 0 &amp;&amp; lrcIndex &lt; lrcLines.length) {&#10;    const lineId = lrcLines[lrcIndex]._id.$oid;&#10;    lineWordsMap.set(lineId, currentLineWords);&#10;  }&#10;&#10;  return lineWordsMap;&#10;};&#10;&#10;export const createLineWordsLookup = (&#10;  songData: SongData&#10;): Map&lt;string, WordEntry[]&gt; =&gt; {&#10;  const richSyncWords = songData.richSync?.words ?? [];&#10;  return mapWordsToLines(songData.lrc, richSyncWords);&#10;};&#10;&#10;export const hasValidRichSync = (songData: SongData): boolean =&gt; {&#10;  return Boolean(&#10;    songData.richSync?.words &amp;&amp;&#10;    songData.richSync.words.length &gt; 0 &amp;&amp;&#10;    songData.richSync.status !== 'error'&#10;  );&#10;};&#10;&#10;export const getWordsForLine = (&#10;  lineWordsMap: Map&lt;string, WordEntry[]&gt;,&#10;  lineId: string&#10;): readonly WordEntry[] =&gt; {&#10;  return lineWordsMap.get(lineId) ?? [];&#10;};&#10;&#10;export const findCurrentIndexByRichSync = (&#10;  lineWordsMap: Map&lt;string, WordEntry[]&gt;,&#10;  lrcLines: readonly LrcLine[],&#10;  currentTimeMs: number&#10;): number =&gt; {&#10;  if (lineWordsMap.size === 0) {&#10;    return findCurrentIndex(lrcLines, currentTimeMs);&#10;  }&#10;&#10;  for (let i = 0; i &lt; lrcLines.length; i++) {&#10;    const lineId = lrcLines[i]._id.$oid;&#10;    const words = lineWordsMap.get(lineId);&#10;&#10;    if (!words || words.length === 0) {&#10;      continue;&#10;    }&#10;&#10;    const firstWord = words[0];&#10;    const lastWord = words[words.length - 1];&#10;    const lineStart = firstWord.start;&#10;    const lineEnd = lastWord.end;&#10;&#10;    if (currentTimeMs &gt;= lineStart &amp;&amp; currentTimeMs &lt; lineEnd) {&#10;      return i;&#10;    }&#10;&#10;    if (currentTimeMs &gt;= lineEnd) {&#10;      const nextLine = lrcLines[i + 1];&#10;      if (nextLine) {&#10;        const nextLineWords = lineWordsMap.get(nextLine._id.$oid);&#10;        if (nextLineWords &amp;&amp; nextLineWords.length &gt; 0) {&#10;          const nextLineStart = nextLineWords[0].start;&#10;          if (currentTimeMs &lt; nextLineStart) {&#10;            return i;&#10;          }&#10;        } else {&#10;          return i;&#10;        }&#10;      } else {&#10;        return i;&#10;      }&#10;    }&#10;  }&#10;&#10;  return -1;&#10;};&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>